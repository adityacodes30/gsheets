/**
* @license Apache-2.0
*
* Copyright (c) 2023 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isNonNegativeInteger = require( '@stdlib/assert-is-nonnegative-integer' ).isPrimitive;
var isInteger = require( '@stdlib/assert-is-integer' ).isPrimitive;
var isNumber = require( '@stdlib/assert-is-number' ).isPrimitive;
var isOrder = require( '@stdlib/ndarray-base-assert-is-order' );
var isBufferLengthCompatible = require( '@stdlib/ndarray-base-assert-is-buffer-length-compatible' );
var lowercase = require( '@stdlib/string-base-lowercase' );
var contains = require( '@stdlib/array-base-assert-contains' ).factory;
var orders = require( '@stdlib/ndarray-orders' );
var ndarray = require( '@stdlib/ndarray-base-ctor' );
var numel = require( '@stdlib/ndarray-base-numel' );
var format = require( '@stdlib/string-format' );
var isRange1d = require( '@stdlib/gsheets/assert/base/is-range1d' );
var flatten2d = require( '@stdlib/gsheets/array/flatten2d' );


// VARIABLES //

var ORDERS = orders();
var DTYPES = [
	'string',
	'number',
	'complex',
	'boolean',
	'date',
	'any'
];

var HEADER_FIELDS = [
	'ndarray',  // len=0
	'shape',    // len=ndims
	'strides',  // len=ndims (and minimum 1)
	'offset',   // len=1
	'order',    // len=1
	'dtype',    // len=1
	'length',   // len=1
	'capacity', // len=1
	'data'      // len>=0
];
var NFIELDS = HEADER_FIELDS.length;
var NFIELDS_SINGLE_VALUES = 5;


// FUNCTIONS //

/**
* Tests whether an input value is a valid data type.
*
* @private
* @name isDType
* @type {Function}
* @param {*} value - input value
* @returns {boolean} boolean indicating whether an input value is a valid data type
*
* @example
* var bool = isDType( 'number' );
* // returns true
*
* bool = isDType( 'abcdef' );
* // returns false
*/
var isDType = contains( DTYPES );

/**
* Initialize an output object.
*
* @private
* @returns {Object} initialized output object
*
* @example
* var o = initOutput();
* // returns <Object>
*/
function initOutput() {
	return {
		'ndims': 0,
		'shape': null,
		'strides': null,
		'offset': -1, // sentinel value
		'order': '',
		'dtype': '',
		'length': -1, // sentinel value
		'capacity': -1, // sentinel value
		'ndarray': null,
		'headerLength': 0,
		'rawBuffer': null
	};
}

/**
* Returns an ndarray shape.
*
* @private
* @param {Array} buf - ndarray data
* @param {NonNegativeInteger} idx - starting index
* @throws {TypeError} must provide a valid shape
* @returns {Array} ndarray shape
*/
function getShape( buf, idx ) {
	var out;
	var v;
	var i;

	out = [];
	for ( i = idx; i < buf.length; i++ ) {
		v = buf[ i ];
		if ( !isNumber( v ) ) {
			break;
		}
		if ( !isNonNegativeInteger( v ) ) {
			throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. "shape" field must only contain nonnegative integers. Value: "%s".', v ) );
		}
		out.push( v );
	}
	return out;
}

/**
* Returns ndarray strides.
*
* @private
* @param {Array} buf - ndarray data
* @param {NonNegativeInteger} idx - starting index
* @throws {TypeError} must provide valid strides
* @returns {Array} ndarray strides
*/
function getStrides( buf, idx ) {
	var out;
	var v;
	var i;

	out = [];
	for ( i = idx; i < buf.length; i++ ) {
		v = buf[ i ];
		if ( !isNumber( v ) ) {
			break;
		}
		if ( !isInteger( v ) ) {
			throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. "strides" field must only contain integers. Value: "%s".', v ) );
		}
		out.push( v );
	}
	return out;
}

/**
* Parses ndarray header fields.
*
* @private
* @param {Array} x - raw ndarray data
* @param {Object} out - destination object
* @throws {TypeError} must provide a valid ndarray range
* @returns {Object} destination object
*/
function parseHeader( x, out ) {
	var v;
	var o;
	var i;

	// Check for a header element marking the beginning of an ndarray range:
	if ( x[ 0 ] !== 'ndarray' ) {
		throw new TypeError( format( 'invalid argument. The first field in a range representing an ndarray must equal the string "ndarray", thus marking the beginning of an ndarray range. Value: "%s".', x[ 0 ] ) );
	}
	// Parse the remaining header fields...
	for ( i = 1; i < x.length; i++ ) {
		// Allow for field names to be either upper or lower case:
		o = lowercase( x[ i ] );

		if ( o === 'shape' ) {
			out.shape = getShape( x, i+1 );
			out.ndims = out.shape.length;
			i += out.ndims;
		} else if ( o === 'strides' ) {
			out.strides = getStrides( x, i+1 );
			i += out.strides.length;
		} else if ( o === 'offset' ) {
			i += 1;
			v = x[ i ];
			if ( !isNonNegativeInteger( v ) ) {
				throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. "offset" field must be a nonnegative integer. Value: "%s".', v ) );
			}
			out.offset = v;
		} else if ( o === 'order' ) {
			i += 1;
			v = lowercase( x[ i ] );
			if ( !isOrder( v ) ) {
				throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. "order" field must be one of the following: "%s". Value: "%s".', ORDERS.join( '", "' ), v ) );
			}
			out.order = v;
		} else if ( o === 'dtype' ) {
			i += 1;
			v = lowercase( x[ i ] );
			if ( !isDType( v ) ) {
				throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. "dtype" field must be one of the following: "%s". Value: "%s".', DTYPES.join( '", "' ), v ) );
			}
			out.dtype = v;
		} else if ( o === 'length' ) {
			i += 1;
			v = x[ i ];
			if ( !isNonNegativeInteger( v ) ) {
				throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. "length" field must be a nonnegative integer.' );
			}
			out.length = v;
		} else if ( o === 'capacity' ) {
			i += 1;
			v = x[ i ];
			if ( !isNonNegativeInteger( v ) ) {
				throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. "capacity" field must be a nonnegative integer. Value: "%s".', v ) );
			}
			out.capacity = v;
		} else if ( o === 'data' ) {
			i += 1;
			break;
		} else {
			throw new TypeError( format( 'invalid argument. Range presenting an ndarray is invalid. Unrecognized ndarray field. Value: "%s".', o ) );
		}
	}
	return out;
}

/**
* Calculates the expected header length.
*
* @private
* @param {NonNegativeInteger} ndims - number of dimensions
* @param {PositiveInteger} nstrides - number of strides
* @returns {PositiveInteger} header length
*/
function headerLength( ndims, nstrides ) {
	// Number of fields + shape.length + strides.length + number of fields having a single value:
	return NFIELDS + ndims + nstrides + NFIELDS_SINGLE_VALUES;
}

/**
* Verifies parsed ndarray header information.
*
* @private
* @param {Object} o - object containing ndarray data
* @throws {TypeError} must provide a valid ndarray range
* @returns {Object} input object
*/
function verifyHeader( o ) {
	var ndims;
	var len;

	ndims = o.ndims;
	if ( o.shape === null ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "shape" field.' );
	}
	if ( o.strides === null ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "strides" field.' );
	}
	if ( ndims > 0 && o.strides.length !== ndims ) {
		throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. Number of strides does not match the number of dimensions. Number of dimensions: %d. Number of strides: %d.', ndims, o.strides.length ) );
	} else if ( ndims === 0 && ( o.strides.length !== 1 || o.strides[ 0 ] !== 0 ) ) { // eslint-disable-line max-len
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. A zero-dimensional ndarray must have a single stride equal to 0.' );
	}
	if ( o.offset === -1 ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "offset" field.' );
	}
	if ( o.order === '' ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "order" field.' );
	}
	if ( o.dtype === '' ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "dtype" field.' );
	}
	if ( o.length === -1 ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "length" field.' );
	}
	len = numel( o.shape );
	if ( len !== o.length ) {
		throw new TypeError( format( 'invalid argument. Range representing an ndarray is invalid. The "length" field is not consistent with the "shape" field. Expected length: "%s". Computed length: "%s".', o.length, len ) );
	}
	if ( o.capacity === -1 ) {
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. Missing "capacity" field.' );
	}
	if ( len > 0 && !isBufferLengthCompatible( o.capacity, o.shape, o.strides, o.offset ) ) { // eslint-disable-line max-len
		throw new TypeError( 'invalid argument. Range representing an ndarray is invalid. The "capacity" field is incompatible with the specified ndarray meta data. Ensure that the "offset" field is valid with regard to the "strides" field and that the data buffer has enough elements to satisfy the desired ndarray shape.' );
	}
	return o;
}


// MAIN //

/**
* Converts a range to an ndarray.
*
* @param {Array<Array>} range - input range
* @throws {TypeError} must provide a valid ndarray range
* @returns {Object} object containing ndarray data
*
* @example
* var range = [
*     [ 'ndarray' ],
*     [ 'shape' ],
*     [ 2 ],
*     [ 2 ],
*     [ 'strides' ],
*     [ 2 ],
*     [ 1 ],
*     [ 'offset' ],
*     [ 0 ],
*     [ 'order' ],
*     [ 'row-major' ],
*     [ 'dtype' ],
*     [ 'number' ],
*     [ 'length' ],
*     [ 4 ],
*     [ 'capacity' ],
*     [ 4 ],
*     [ 'data' ],
*     [ 1 ],
*     [ 2 ],
*     [ 3 ],
*     [ 4 ]
* ];
*
* var obj = range2ndarray( range );
* // returns <Object>
*
* var arr = obj.ndarray;
* // returns <ndarray>
*
* var sh = obj.shape;
* // returns [ 2, 2 ]
*
* var st = obj.strides;
* // returns [ 2, 1 ]
*/
function range2ndarray( range ) {
	var out;

	if ( !isRange1d( range ) ) {
		throw new TypeError( 'invalid argument. A range representing an ndarray must be either a single row or a single column.' );
	}
	// Initialize an output object:
	out = initOutput();

	// Convert the input range (a nested array of arrays) to a flat one-dimensional array:
	out.rawBuffer = flatten2d( range );

	// Parse the ndarray header:
	out = parseHeader( out.rawBuffer, out );

	// Verify that the provided range is not missing any fields and that fields are consistent with one another:
	out = verifyHeader( out );

	// Compute the header length:
	out.headerLength = headerLength( out.ndims, out.strides.length );

	// Create an ndarray view, adjusting the offset to account for the header info:
	out.ndarray = new ndarray( 'generic', out.rawBuffer, out.shape, out.strides, out.offset+out.headerLength, out.order );

	return out;
}


// EXPORTS //

module.exports = range2ndarray;
