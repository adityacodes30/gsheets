/**
* @license Apache-2.0
*
* Copyright (c) 2023 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isString = require( '@stdlib/assert-is-string' ).isPrimitive;
var base = require( '@stdlib/slice-base-seq2multislice' );
var format = require( '@stdlib/string-format' );


// MAIN //

/**
* Converts a subsequence indexing expression to a multi-slice object.
*
* @param {string} slice - subsequence indexing expression
* @param {Array<integer>} shape - array shape
* @param {boolean} strict - boolean indicating whether to enforce strict bounds checking
* @throws {TypeError} must provide a valid indexing expression
* @throws {RangeError} slice exceeds index bounds
* @returns {MultiSlice} multi-slice object
*
* @example
* // TODO
*/
function seq2multislice( slice, shape, strict ) {
	var s;
	if ( !isString( slice ) ) {
		throw new TypeError( format( 'invalid argument. A slice indexing expression must be a string. Value: "%s".', slice ) );
	}
	s = base( slice, shape, true );
	if ( s.code ) {
		if ( s.code === 'ERR_SLICE_INVALID_SUBSEQUENCE' ) {
			throw new TypeError( 'invalid argument. The provided slice indexing expression is not a valid subsequence.' );
		}
		if ( s.code === 'ERR_SLICE_INVALID_INCREMENT' ) {
			throw new TypeError( 'invalid argument. The provided slice indexing expression is not a valid subsequence. The increment must be a non-zero integer value.' );
		}
		if ( s.code === 'ERR_SLICE_TOO_MANY_DIMENSIONS' ) {
			throw new TypeError( 'invalid argument. The provided slice indexing expression includes excess dimensions.' );
		}
		if ( s.code === 'ERR_SLICE_INSUFFICIENT_DIMENSIONS' ) {
			throw new TypeError( 'invalid argument. The provided slice indexing expression has too few dimensions.' );
		}
		if ( s.code === 'ERR_SLICE_INVALID_ELLIPSIS' ) {
			throw new TypeError( 'invalid argument. The provided slice indexing expression is not a valid subsequence. A subsequence must only contain at most one ellipsis.' );
		}
		// NOTE: the following error check must come last due to fall-through when in non-strict mode...
		if ( s.code === 'ERR_SLICE_OUT_OF_BOUNDS' ) {
			if ( strict ) {
				throw new RangeError( 'invalid argument. The provided slice indexing expression resolves to a slice exceeding index bounds.' );
			}
			// Repeat parsing, this time allowing for out-of-bounds slices:
			s = base( slice, shape, false );
		}
	}
	return s;
}


// EXPORTS //

module.exports = seq2multislice;
